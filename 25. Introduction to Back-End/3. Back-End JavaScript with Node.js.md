# Introduction to Node.js

## The Console Module
One of the most commonly used Node.js core modules is the console module. In Node.js, the terminal is used to send and receive text feedback to and from a program, often for debugging purposes. This may sound familiar to how we use the console in the web browser. That’s because in Node.js, the built-in console module exports a global console object that gives the terminal similar functionality. The console object provides many of the same familiar methods such as:
* .log() — to print messages to the terminal.
* .assert() — to print a message to the terminal if the value is falsy.
* .table() — to print out a table in the terminal from an object or array.

Since console is a global module, its methods can be accessed from anywhere, and the require() function is not necessary.
```JS
const petsArray = ['dog', 'cat', 'bird', 'monkey'];

// Add console methods below!
console.log(petsArray)
console.table(petsArray)
console.assert(petsArray.length > 5)
console.log(petsArray.length > 5)
```

```
[ 'dog', 'cat', 'bird', 'monkey' ]
┌─────────┬──────────┐
│ (index) │  Values  │
├─────────┼──────────┤
│    0    │  'dog'   │
│    1    │  'cat'   │
│    2    │  'bird'  │
│    3    │ 'monkey' │
└─────────┴──────────┘
false
Assertion failed
```

## The Process Module
In computer science, a process is the instance of a computer program that is being executed. You can open Task Manager if you’re on a Windows machine or Activity Monitor from a Mac to see information about the various processes running on your computer right now. Node has a global process object with useful methods and information about the current process.

The process.env property is an object which stores and controls information about the environment in which the process is currently running. For example, the process.env object contains a PWD property which holds a string with the directory in which the current process is located. It can be useful to have some if/else logic in a program depending on the current environment— a web application in a development phase might perform different tasks than when it’s live to users. We could store this information on the process.env. One convention is to add a property to process.env with the key NODE_ENV and a value of either production or development.
```JS
if (process.env.NODE_ENV === 'development'){
  console.log('Testing! Testing! Does everything work?');
}
```

The process.memoryUsage() returns information on the CPU demands of the current process. It returns a property that looks similar to this:
```JS
{ rss: 26247168,
  heapTotal: 5767168,
  heapUsed: 3573032,
  external: 8772
}
```

Heap can mean different things in different contexts: a heap can refer to [a specific data structure](https://en.wikipedia.org/wiki/Heap_(data_structure)), but it can also refer to the a block of [computer memory](https://en.wikipedia.org/wiki/Memory_management). process.memoryUsage().heapUsed will return a number representing how many bytes of memory the current process is using.

The process.argv property holds an array of command line values provided when the current process was initiated. The first element in the array is the absolute path to Node, which ran the process. The second element in the array is the path to the file that’s running. The following elements will be any command line arguments provided when the process was initiated. Command line arguments are separated from one another with spaces.
```
node myProgram.js testing several features
```

```JS
console.log(process.argv[3]); // Prints 'several'
```

We’ve only covered a few of the properties of the process object, so make sure to check out the [documentation on the process object](https://nodejs.org/api/process.html) to learn more about it and explore some of its other methods and properties.

## The OS Module
When developing or debugging an app, it can be helpful to have information about the computer, operating system, and network on which the program is running. Before Node, this information could not be retrieved using JavaScript due to the language being confined to the browser. However, Node.js is a JavaScript runtime, which means it can execute code outside of the browser, and we’re able to get access to much of this information through the os core module.

Unlike process and console, the os module is not global and needs to be included into the file in order to gain access to it’s methods. You can include the os module into your file by typing:
```JS
const os = require('os');
```

With the os module saved to the os variable, you can call methods like:
* os.type() — to return the computer’s operating system.
* os.arch() — to return the operating system CPU architecture.
* os.networkInterfaces — to return information about the network interfaces of the computer, such as IP and MAC address.
* os.homedir() — to return the current user’s home directory.
* os.hostname() — to return the hostname of the operating system.
* os.uptime() — to return the system uptime, in seconds.

Let’s take a look at an example:
```JS
const os = require('os');
 
const local = {  
  'Home Directory': os.homedir(),    
  'Operating System': os.type(),
  'Last Reboot': os.uptime()
}
```

In the above example code, we first require the os module and store it in a variable, os. Below that, we have an object, local, that will hold some information about the user’s computer: the name of the home directory, the type of operating system, and the time since the computer was last rebooted.
```
  {
    'Home Directory': '/Users/luca',
    'Operating System': 'Darwin',
    'Time since reboot': 86997
  }
```

When we run the program, the local object stores all the requested information:
* the user’s home directory — '/Users/luca',
* the operating system — 'Darwin' ([Darwin](https://en.wikipedia.org/wiki/Darwin_(operating_system)) is the underlying operating system of macOS.),
* and the time since the computer was last rebooted — 86997 seconds.

Feel free to try running some of the os module methods on your own computer to get more information about the hardware, OS, and network you’re on!

## The Util Module
Developers sometimes classify outlier functions used to maintain code and debug certain aspects of a program’s functionality as utility functions. Utility functions don’t necessarily create new functionality in a program, but you can think of them as internal tools used to maintain and debug your code. The Node.js util core module contains methods specifically designed for these purposes. The util module can be required into the file using:
```JS
const util = require('util');
```

Once required, you have access to many useful objects and methods within the util module. One important object is types, which provides methods for runtime type checking in Node.
```JS
const util = require('util');
 
const today = new Date();
const earthDay = 'April 22, 2022';
 
console.log(util.types.isDate(today));
console.log(util.types.isDate(earthDay));
```

In the above example, we first require in the util module. Next, we declare two variables: today stores today’s date as an instance of the Date object, and earthDay stores the date of Earth Day as a string. We then log the results of type checking each variable using util.types.isDate(). The types.isDate() method checks for Date objects and returns a boolean value, giving us:
```
true
false
```

Since today is a Date object, it returns true, and since earthDay is a string, it returns false!

Another important util method is .promisify(), which turns callback functions into promises. As you know, [asynchronous programming is essential to Node.js](https://www.codecademy.com/content-items/9abb26ac5476a0967d2675d03fce444c). In the beginning, this asynchrony was achieved using error-first callback functions, which are still very prevalent in the Node ecosystem today. But since promises are often preferred over callbacks [and especially nested callbacks](http://callbackhell.com/), Node offers a way to turn these into promises. Let’s take a look:
```JS
function getUser (id, callback) {
  return setTimeout(() => {
    if (id === 5) {
      callback(null, { nickname: 'Teddy' })
    } else {
      callback(new Error('User not found'))
    }
  }, 1000)
}
 
function callback (error, user) {
  if (error) {
    console.error(error.message)
    process.exit(1)
  }
 
  console.log(`User found! Their nickname is: ${user.nickname}`)
}
 
getUser(1, callback) // -> `User not found`
getUser(5, callback) // -> `User found! Their nickname is: Teddy`
```

Here we have a function that queries a database for a specified user ID. getUser methods are very common in back-end applications, and most will also support error-first callbacks. Since a database query typically takes longer to run than other operations, we simulate the query with a setTimeout() method that executes a callback function after 1000 milliseconds (or 1 second). If the user with the specified ID is found, the callback function is executed with null passed in as the argument for the error parameter, and an object containing the returned user information is passed in as an argument for the user parameter. If the user is not found, the callback function is executed, passing in a new Error as the argument for the error parameter. A second argument for user is not necessary since the function will end in the case of an error.

This way of handling this function may seem a bit convoluted these days, but with .promisify(), we can easily change it into a modern, cleaner, and more maintainable version of itself:
```JS
const getUserPromise = util.promisify(getUser);
 
getUserPromise(id)
  .then((user) => {
      console.log(`User found! Their nickname is: ${user.nickname}`);
  })
  .catch((error) => {
      console.log('User not found', error);
  });
 
getUser(1) // -> `User not found`
getUser(5) // -> `User found! Their nickname is: Teddy`
```

We declare a getUserPromise variable that stores the getUser method turned into a promise using the .promisify() method. With that in place, we’re able to use getUserPromise with .then() and .catch() methods (or we could also use the async...await syntax here) to resolve the promise returned or catch any errors.

## Review
Awesome work! You’ve learned a lot about some fundamental Node.js concepts and modules. Let’s take a moment to review what we learned:
* Node.js is a JavaScript runtime, an environment that allows us to execute our JavaScript code by converting it into something a computer can understand.
* REPLs are processes that read, evaluate, print, and repeat (loop), and Node.js comes with its own REPL we can access in our terminal with the node command.
* We run JavaScript programs with Node in the terminal by typing node followed by the file name (if we’re in the same directory) or the absolute path of the file.
* Code can be organized into separate files, modules, and combined through requiring them where needed using the require() function.
* Core modules are built into the Node.js environment to efficiently perform common tasks.
* The console module exports a global console object allowing the terminal to act as a debugging console, similar to the JavaScript console object provided by web browsers.
* The process module is a global module that gives access to information about the Node.js runtime environment.
* The os module provides methods to retrieve information about the computer, operating system, and network interfaces.
* The util module contains methods used to maintain and debug your code.

You learned some of the key core modules built into Node.js, but as you know, there are many more. You can even create your own modules, as well as use third-party modules built by other developers. But don’t worry! A good thing to remember when learning Node is that it’s not necessary to memorize every module, method, or other specific aspects of the environment. The best way to get comfortable with Node is to practice making things with it. Your imagination is the limit! So keep going to learn how to download Node on your local machine.