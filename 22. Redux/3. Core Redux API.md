# Index
* [Intro to the Core Redux API](#intro-to-the-core-redux-api)
* [Strategies for Complex State](#strategies-for-complex-state)
* [Implementing the Redux Store from Scratch](#implementing-the-redux-store-from-scratch)

# Intro to the Core Redux API

## What is the Redux API?
In this lesson, you will learn how to apply the core concepts of Redux to a real Redux application.

Remember, Redux applications are built upon a one-way flow of data model and are managed by the store:
* The state is the set of data values that describes the application. It is used to render the user interface (UI).
* Users interact with the UI which dispatch actions to the store. An action is an object that expresses a desired change to the state.
* The store generates its next state using a reducer function which receives the most recent action and the current state as inputs.
* Finally, the UI is re-rendered based on the new state of the store and the entire process can begin again.

Building an application that follows the core principles of Redux can be done without external libraries. However, the dedicated [Redux library](https://redux.js.org/) provides some very useful tools for handling the most common aspects of building a Redux application and helps ensure that the core Redux principles are enforced.

This lesson will focus on creating a basic Redux application with the createStore() method from the Redux API and the following related store methods:
* store.getState()
* store.dispatch(action)
* store.subscribe(listener)

Note: The store method store.replaceReducer(nextReducer) is an advanced method and will not be covered in this course.

## Install the Redux Library
The core concepts of Redux are closely tied to a framework known as [Flux](https://facebook.github.io/flux/docs/in-depth-overview/). Both share the same concept of a one-way flow of data and a centralized store to reduce actions into the application‚Äôs next state. While Flux was designed as a general pattern which one could follow to build applications, Redux is a library that provides concrete methods to help implement the framework.

To make use of the Redux package, it can be installed using the Node Package Manager (npm). Then, its methods can be imported.

Let‚Äôs start by installing the redux package and importing its createStore() method. In the next exercise you‚Äôll learn how to use this method.
```
npm install redux
```

```JS
import { createStore } from 'redux';
```

## Create a Redux Store
As you know, every Redux application uses a reducer function that describes which actions can update the state and how those actions lead to the next state.

For example, suppose you wanted to build an application for a light switch. Its reducer might look like this:
```JS
const initialState = 'on';
const lightSwitchReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'toggle':
      return state === 'on' ? 'off' : 'on';
    default:
      return state;
  }
}
```

This reducer handles a single action type 'toggle' and returns the next state of the store: 'on' if it had been 'off' and vice-versa. If an unrecognized action is received, the current state of the store is returned.

The programmer could manually execute the reducer with the current state of the store and the desired action to perform like so:
```JS
let state = 'on';
state = lightSwitchReducer(state, { type: 'toggle' });
console.log(state); // Prints 'off'
```

However, this is the main responsibility of the store. The store is an object that enforces the one-way data flow model that Redux is built upon. It holds the current state inside, receives action dispatches, executes the reducer to get the next state, and provides access to the current state for the UI to re-render.

Redux exports a valuable helper function for creating this store object called createStore(). The createStore() helper function has a single argument, a reducer function.

To create a store with lightSwitchReducer, you could write:
```JS
import { createStore } from 'redux'
 
const initialState = 'on';
const lightSwitchReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'toggle':
      return state === 'on' ? 'off' : 'on';
    default:
      return state;
  }
}
 
const store = createStore(lightSwitchReducer);
```

For the remainder of this lesson, you will be building a simple counter application, whose state is a single number, using the Redux library.

In the code editor, you will find the initialState value as well as countReducer, which describes how the state can be updated in response to an 'increment' action.

## Dispatch Actions to the Store
The store object returned by createStore() provides a number of useful methods for interacting with its state as well as the reducer function it was created with.

The most commonly used method, store.dispatch(), can be used to dispatch an action to the store, indicating that you wish to update the state. Its only argument is an action object, which must have a type property describing the desired state change.
```JS
const action = { type: 'actionDescriptor' }; 
store.dispatch(action);
```

Each time store.dispatch() is called with an action object, the store‚Äôs reducer function will be executed with the same action object. Assuming that the action.type is recognized by the reducer, the state will be updated and returned.

Let‚Äôs see how this works in the lightswitch application from the last exercise:
```JS
import { createStore } from 'redux';
 
const initialState = 'on';
const lightSwitchReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'toggle':
      return state === 'on' ? 'off' : 'on';
    default:
      return state;
  }
}
 
const store = createStore(lightSwitchReducer);
 
console.log(store.getState()); // Prints 'on'
 
store.dispatch({ type: 'toggle' }); 
console.log(store.getState()); // Prints 'off'
 
store.dispatch({ type: 'toggle' });
console.log(store.getState()); // Prints 'on'
```

In this example, you can also see another store method, store.getState(), which returns the current value of the store‚Äôs state. Printing its value between each dispatched action allows us to see how the store‚Äôs state changes.

Internally, when the store executes its reducer, it uses store.getState() as the state argument. Though you won‚Äôt see it, you can imagine that, when an action is dispatched like this‚Ä¶
```JS
store.dispatch({ type: 'toggle'});
```

‚Ä¶the store calls the reducer like this:
```JS
lightSwitchReducer(store.getState(), { type: 'toggle' });
```

## Action Creators
As you saw in the last exercise, you are likely to dispatch actions of the same type multiple times or from multiple places. Typing out the entire action object can be tedious and creates opportunities to make an error.

For example, in the light switch application, whose reducer accepts 'toggle' actions to turn the light 'on' or 'off', you might write:
```JS
store.dispatch({Type:'toggle'});
store.dispatch({type:'toggel'});
store.dispatch({typo:'toggle'});
```

Did you spot the errors?

In most Redux applications, action creators are used to reduce this repetition and to provide consistency. An action creator is simply a function that returns an action object with a type property. They are typically called and passed directly to the store.dispatch() method resulting in fewer errors and an easier-to-read dispatch statement.

The above code could be rewritten using an action creator called toggle() like so:
```JS
const toggle = () => {
  return { type: "toggle" };
}
store.dispatch(toggle()); // Toggles the light to 'off'
store.dispatch(toggle()); // Toggles the light back to 'on'
store.dispatch(toggle()); // Toggles the light back to 'off'
```

Though not necessary in a Redux application, action creators save us the time needed to type out the entire action object, reduce the chances you make a typo, and improve the readability of our application.

Often, before the reducer of an application is even written, Redux programmers will write action creators as a way of planning out which actions will be available to dispatch to the store.

## Respond to State Changes
In a typical web application, user interactions that trigger [DOM events](https://developer.mozilla.org/en-US/docs/Web/Events) ("click", "keydown", etc‚Ä¶) can be listened for and responded to using an [event listener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener).

Similarly, in Redux, actions dispatched to the store can be listened for and responded to using the store.subscribe() method. This method accepts one argument: a function, often called a listener, that is executed in response to changes to the store‚Äòs state.
```JS
const reactToChange = () => console.log('change detected!');
store.subscribe(reactToChange);
```

In this example, each time an action is dispatched to the store, and a change to the state occurs, the subscribed listener, reactToChange(), will be executed.

Sometimes it is useful to stop the listener from responding to changes to the store, so store.subscribe() returns an unsubscribe function.

We can see this in action in the light switch application:
```JS
// lightSwitchReducer(), toggle(), and store omitted...
 
const reactToChange = () => {
  console.log(`The light was switched ${store.getState()}!`);
}
const unsubscribe = store.subscribe(reactToChange);
 
store.dispatch(toggle());
// reactToChange() is called, printing:
// 'The light was switched off!'
 
store.dispatch(toggle());
// reactToChange() is called, printing:
// 'The light was switched on!'
 
unsubscribe(); 
// reactToChange() is now unsubscribed
 
store.dispatch(toggle());
// no print statement!
 
console.log(store.getState()); // Prints 'off'
```

* In this example, the listener function reactToChange() is subscribed to the store
* Each time an action is dispatched, reactToChange() is called and prints the current value of the light switch. It is common for callbacks subscribed to the store to use store.getState() inside them.
* After the first two dispatched actions, unsubscribe() is called causing reactToChange() to no longer be exectued in response to further dispatches made to store.

Note: It is not always required to use the unsubscribe() function returned by store.subscribe(), though it is useful to know that it exists.

Now, take a look at store.js in the code editor. You will see that a few actions have been dispatched to the store of the counter application. Suppose you wanted to print the current value of store.getState() each time the state changes. While you could write something like this‚Ä¶
```JS
store.dispatch(decrement());
console.log(`The count is ${store.getState()}`);
store.dispatch(increment());
console.log(`The count is ${store.getState()}`);
store.dispatch(increment());
console.log(`The count is ${store.getState()}`);
```

‚Ä¶we know that this approach is repetitive. Instead, you can subscribe a change listener to print out the current state in response to state changes automatically.

## Connect the Redux Store to a UI
Up until now, you have built a working counting application using Redux that lacks a proper user interface (UI). Let‚Äôs change that!

The UI for this application should display the current count number and allow the user to increment or decrement this value using the buttons provided. Take a look at the connected web browser window and you can see that the elements for such an interface are present, but they haven‚Äôt been connected to the Redux store yet.

Connecting a Redux store with any UI requires a few consistent steps, regardless of how the UI is implemented:
* Create a Redux store
* Render the initial state of the application.
* Subscribe to updates. Inside the subscription callback:
  * Get the current store state
  * Select the data needed by this piece of UI
  * Update the UI with the data
* Respond to UI events by dispatching Redux actions

These same steps are followed when building an interface using React, Angular, or jQuery. For now, we‚Äôll create a very simple user interface for the counting application using the [HTML DOM API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API).

Open up the index.html file and you can see the three HTML elements that are currently being rendered:
```HTML
<p id='counter'>Waiting for current state.</p>
<button id='incrementer'>+</button>
<button id='decrementer'>-</button>
```

Now, open up store.js where you will find the pieces of Redux code that you have built throughout this lesson: the action creators increment() and decrement(), the reducer countReducer, and the store that ties it all together. Additionally, the following values have been added:
* counterElement, incrementer, and decrementer: references to the HTML elements in index.html
* render: A state-change listener for responding to changes to the store‚Äòs state.
* incrementerClicked and decrementerClicked: DOM event handlers for responding to the buttons being clicked by the user.

These new functions and elements will allow us to plug the Redux store into the UI. Let‚Äôs begin.

## React and Redux
As you saw in the last exercise, Redux can be used within the context of any UI framework, though it is most commonly paired with React. This makes sense considering that React and Redux were both developed by [engineers at Facebook](https://en.wikipedia.org/wiki/Redux_(JavaScript_library)#History).

We can be more specific about the common steps involved in connecting Redux to a React UI:
* A render() function will be subscribed to the store to re-render the top-level React Component.
* The top-level React component will receive the current value of store.getState() as a prop and use that data to render the UI.
* Event listeners attached to React components will dispatch actions to the store.

Take a look at store.js in the code editor. Here, you can see the completed light switch application following this pattern.
* The render() function is subscribed to the store.
* store.getState() is passed as a prop called state to the <LightSwitch /> component.
* The LightSwitch component displays the current state of the store, either 'on' or 'off', and adjusts the background colors accordingly.
* The LightSwitch component declares a click handler that dispatches a toggle() action to the store.

Note 1: The prop name state isn‚Äôt a special React name and can be customized as the programmer sees fit. For example, lightSwitchState={store.getState()} would also be valid.

## Implementing a React+Redux App
Now that you have implemented the counter app using the HTML DOM API, and have seen a working React+Redux application, it is time to implement it using React.

Take a look at the store.js file and you will find the following functions and values have been defined for you:
* The action creators increment() and decrement()
* The store and its reducer countReducer()
* A React component called CounterApp which declares two event handlers, onIncrementButtonClicked and onDecrementButtonClicked
* A render() function which renders CounterApp using ReactDOM.render()

The React component CounterApp and the render() function are entirely disconnected from the Redux store. Let‚Äôs change that!

## Review
Congratulations! You were able to apply the core concepts of the Redux framework by implementing an application using the Redux library.

By completing this lesson, you are now able to:
* Install the redux library into your project using npm install redux.
* Import the createStore() helper function from the 'redux' library.
* Create a store object that holds the entire state of your Redux application using createStore().
* Get the current state of the store using store.getState().
* Dispatch actions to the store using store.dispatch(action).
* Create action creators to reduce the repetitive creation of action objects.
* Register a change listener function to respond to changes to the store using store.subscribe(listener).
* Recognize the pattern for connecting Redux to any user interface.
* Implement a Redux application using either the HTML DOM API or React.
Throughout this lesson, you may have thought to yourself that Redux adds a lot of unnecessary complexity to these simple applications. We implemented Redux in a very basic way, which is useful for learning but not how it‚Äôs done in the real world.

Redux shines when it is used in applications with many features and a lot of data where having a centralized store to keep it all organized is advantageous. In the next lesson, you will learn how to build and organize Redux applications with complex state.

# Strategies for Complex State

## Introduction to Strategies for Complex State
In the last lesson, you built a simple counter app whose store state was just a single number. Though the counter app illustrates how Redux can manage the state of an application, it isn‚Äôt a great example of an application that needs Redux.

Redux really shines when used in applications with many features and a lot of data where having a centralized store to keep it all organized is advantageous. In this lesson, you will learn strategies for managing an application with a more complex store state and, in the process, you will begin to build an app that will grow throughout the rest of this course.

In the browser, you can see the final product. This application, which we will refer to as the ‚ÄúRecipes App‚Äù, does the following:
* displays a set of recipes which are pulled from a database.
* allows the user to add/remove their favorite recipes to/from a separate list.
* allows the user to enter a search term to filter the visible recipes.

Now, imagine you are working for the software development company whose main product is this Recipes application. The product manager has determined the desired features and functionality, the graphic designer has defined its style, and the React engineer has created its components. Now it is up to you, the Redux Engineer, to design the state management system that can put it all together!

In reality, the Front-End Engineer would implement both React and Redux.

Before continuing on, make sure that you are familiar with the following terms and concepts relating to React and Redux:
* React
  * How to create components
  * How to render components using ReactDOM.render()
  * How to nest components and pass data through props
* Redux
  * One-way data flow model: State ‚Üí View ‚Üí Actions ‚Üí State ‚Üí View ‚Ä¶
  * How to create a reducer function: (state, action) => nextState
  * How to write action objects and action creators
  * How to create a store using createStore()
  * How to use the store methods getState(), dispatch(), and subscribe()

## Slices
Redux is best suited for complex applications with many features that each have some state-related data to be managed. In these cases, objects are the go-to data type to represent the entire store‚Äôs state.

For example, consider a todo app that allows a user to:
* add to a list of todos
* mark individual todos as complete or incomplete
* apply a filter to show only the completed todos, only the incomplete todos, or all of the todos

After adding a few todos and setting the filter to show incomplete todos, the state might look like this:
```JS
state = {
  todos: [
    {
      id: 0, 
      text: 'Complete the Learn Redux course', 
      isCompleted: false
    },
    {
      id: 1, 
      text: 'Build a counter app', 
      isCompleted: true
    },
  ],
  visibilityFilter: 'SHOW_INCOMPLETE'
};
```

In a Redux application, the top-level state properties, state.todos and state.visibilityFilter, are known as slices. Each slice typically represents a different feature of the entire application. Notice that a slice can be any data value, like an array of objects (state.todos) or just a string (state.visibilityFilter).

As a best practice, most Redux applications begin with an initialState that allows the programmer to do two key things:
1. Plan out the general structure of the state
2. Provide an initial state value to the reducer function
For the todo app, this may look like this:
```JS
const initialState = {
  todos: [],
  visibilityFilter: 'SHOW_ALL'
};
const todosReducer = (state = initialState, action) => {
  // rest of todosReducer logic omitted
};
```

The Recipes application will have the following three slices:

allRecipes: an array of all recipe objects
favoriteRecipes: an array of recipe objects chosen by the user from state.allRecipes
searchTerm: a string that filters which recipes are displayed
An example of the store‚Äôs state may look like this:
```JS
state = {
  allRecipes: [
    {id: 0, name: 'Jjampong', img: 'img/jjampong.png' },
    {id: 2, name: 'Cheeseburger', img: 'img/cheeseburger.png' },
    //‚Ä¶ more recipes omitted
  ],
  favoriteRecipes: [
    {id: 1, name: 'Doro Wat', img: 'img/doro-wat.png' },
  ],
  searchTerm: 'Doro'
};
```

Notice that each recipe is represented as an object with an id, name, and img property.

Now that you know what the state structure looks like, the first step is to create an initialState object.

## Actions and Payloads For Complex State
The initialState structure has been defined and you know that the state of this application has 3 slices: allRecipes, favoriteRecipes, and searchTerm. Now, you can begin thinking about how the user will trigger changes to these slices of state through actions.

Remember, actions in Redux are represented by plain JavaScript objects that have a type property and are dispatched to the store using the store.dispatch() method. 

When an application state has multiple slices, individual actions typically only change one slice at a time. Therefore, it is recommended that each action‚Äôs type follows the pattern 'sliceName/actionDescriptor', to clarify which slice of state should be updated.

For example, in a todo application with a state.todos slice, the action type for adding a new todo might be 'todos/addTodo'.

For the Recipes application, what do you think some of the action type strings might be? What user interactions might trigger them to be dispatched?

<b>Write some of your ideas down before revealing the actions you will be using:</b>
1. 'allRecipes/loadData': This action will be dispatched to fetch the needed data from an API right when the application starts.
2. 'favoriteRecipes/addRecipe': This action will be dispatched any time the user clicks on the ‚ù§Ô∏è icon of a recipe from the full set of recipes.
3. 'favoriteRecipes/removeRecipe': This action will be dispatched any time the user clicks on the üíî icon of a recipe from their list of favorites.
4. 'searchTerm/setSearchTerm': This action will be dispatched any time the user changes the text of the search input field to filter the full set of recipes.
5. 'searchTerm/clearSearchTerm': This action will be dispatched any time the user clicks on the ‚ÄúX‚Äù button next to the search input field.

It‚Äôs also important to consider which of these actions will have a payload ‚Äî additional data passed to the reducer in order to carry out the desired change-of-state. For example, consider the actions for the searchTerm slice:
```JS
store.dispatch({ 
  type: 'searchTerm/setSearchTerm', 
  payload: 'Spaghetti' 
});
// The resulting state: { ..., searchTerm: 'Spaghetti' }
 
store.dispatch({ 
  type: 'searchTerm/clearSearchTerm' 
});
// The resulting state: { ..., searchTerm: '' }
```

* When the learner types in a search term, that data needs to be sent to the store so that the React components know which recipes to render and which to hide.
* When the user clears the search field, no additional data needs to be sent because the store can simply set the search term to be an empty string again.

Once you have a clear idea of the types of actions that will be dispatched in your application, when they will be dispatched, and what payload data they will carry, the next step is to make action creators.

Remember, action creators are functions that return a formatted action object.

Action creators enable Redux programmers to re-use action object structures without typing them out by hand and they improve the readability of their code, particularly when dealing with bulky payloads.

Take a look at store.js where you will find that action creators for the two actions above have been defined for you. Your job is to create the remaining three: loadData(), addRecipe(), and removeRecipe()

## Immutable Updates & Complex State
Now that you have defined which changes can occur to your application‚Äôs state, you need a reducer to execute those changes.

Remember, the store‚Äòs reducer function is called each time an action is dispatched. It is passed the action and the current state as arguments and returns the store‚Äòs next state. 

The [second rule of reducers](https://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers#rules-of-reducers) states that when the reducer is updating the state, it must make a copy and return the copy rather than directly mutating the incoming state. When the state is a mutable data type, like an array or object, this is typically done using the spread operator (...).

Below, the todosReducer for a todo app demonstrates this in action:
```JS
const initialState = {
  filter: 'SHOW_INCOMPLETE',
  todos: [
    { id: 0, text: 'learn redux', completed: false },
    { id: 1, text: 'build a redux app', completed: true },
    { id: 2, text: 'do a dance', completed: false },
  ]
};
 
const todosReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'filter/setFilter':
      return {
        ...state,
        filter: action.payload
      };
    case 'todos/addTodo': 
      return {
        ...state,
        todos: [...state.todos, action.payload]
      } ;
    case 'todos/toggleTodo':
      return {
        ...state,
        todos: state.todos.map(todo => {
          return (todo.id === action.payload.id) ? 
            { ...todo, completed: !todo.completed } : 
            todo;
        })
      }
    default:
      return state;
  }
};
```

* The todosReducer uses the initialState as the default state value.
* When a 'filter/setFilter' action is received, it spreads the old state‚Äòs contents (...state) into a new object before updating the filter property with the new filter from action.payload.
* When a 'todos/addTodo' action is received, it does the same except this time, since state.todos is a mutable array, its contents are also spread into a new array, with the new todo from action.payload added to the end.
* When a 'todos/toggleTodo action is received, it uses the .map() method to create a copy of the state.todos array. Additionally, the todo being toggled is found using action.payload.id and it is spread into a new object and updated.

It should be clarified that the state.todos.map() method only makes a ‚Äúshallow‚Äù copy of the array, meaning the objects inside share the same references as the originals. Therefore, mutations to the objects within the copy will affect the objects within the original. For now, we can make do with this solution, but you will learn how to bypass this issue in a later lesson on the [Redux Toolkit](https://redux-toolkit.js.org/).

Now, let‚Äôs create a reducer for the Recipes app! In the store.js file, after the initialState and your action creators, you can see that this function has already been started for you. In the output terminal, you will see the results of printTests() which dispatch some actions to the store. Your task is to complete it such that it can handle each of the five action creator types that you had created in the last exercise.

## Reducer Composition
In the last exercise, you saw how a single reducer was able to handle the logic for updating every slice of the store‚Äòs state. Though this approach does work for these relatively small examples, as the application state becomes increasingly more complex, managing it all with a single reducer will become impractical.

The solution is to follow a pattern called reducer composition. In this pattern, individual slice reducers are responsible for updating only one slice of the application‚Äôs state, and their results are recombined by a rootReducer to form a single state object.
```JS
// Handles only `state.todos`.
const initialTodos = [
  { id: 0, text: 'learn redux', completed: false },
  { id: 1, text: 'build a redux app', completed: true },
  { id: 2, text: 'do a dance', completed: false },
];
const todosReducer = (todos = initialTodos, action) => {
  switch (action.type) {
    case 'todos/addTodo': 
      return [...todos, action.payload]
    case 'todos/toggleTodo':
      return todos.map(todo => {
        return (todo.id === action.payload.id) ? 
          { ...todo, completed: !todo.completed } : 
          {...todo};
      });
    default:
      return todos;
  }
};
 
// Handles only `state.filter`
const initialFilter = 'SHOW_INCOMPLETE',
const filterReducer = (filter = initialFilter, action) => {
  switch (action.type) {
    case 'filter/setFilter':
      return action.payload;
    default:
      return filter;
};
 
const rootReducer = (state = {}, action) => {
  const nextState = {
    todos: todosReducer(state.todos, action),
    filter: filterReducer(state.filter, action)
  };
  return nextState;
};

const store = createStore(rootReducer);
```

In the reducer composition pattern, when an action is dispatched to the store:
* The rootReducer calls each slice reducer, regardless of the action.type, with the incoming action and the appropriate slice of the state as arguments.
* The slice reducers each determine if they need to update their slice of state, or simply return their slice of state unchanged.
* The rootReducer reassembles the updated slice values in a new state object.

One major advantage of this approach is that each slice reducer only receives its slice of the entire application‚Äôs state. Therefore, each slice reducer only needs to immutably update its own slice and doesn‚Äôt care about the others. This removes the problem of copying potentially deeply nested state objects.

Take a look at store.js where you will find that the reducer for the Recipe app that you wrote in the last exercise (which can be found in reducer-old.js) has been partially rewritten to follow the reducer composition pattern:
* The initialState object has been replaced by individual initialSliceName variables which are used as default values for each slice reducer‚Äôs slice of state. This is another common feature of the reducer composition pattern.
* The allRecipesReducer and searchTermReducer slice reducers have been created for you. Notice that they each have a default case.
* Both slice reducers are called within the rootReducer to update their respective slices of state.

All that‚Äôs left is to complete the favoriteRecipesReducer() and include it in the rootReducer()!

## combineReducers
In the reducer composition pattern, the same steps are taken by the rootReducer for each slice reducer:
1. call the slice reducer with its slice of the state and the action as arguments
2. store the returned slice of state in a new object that is ultimately returned by the rootReducer().
```JS
import { createStore } from 'redux';
 
// todosReducer and filterReducer omitted
 
const rootReducer = (state = {}, action) => {
  const nextState = {
    todos: todosReducer(state.todos, action),
    filter: filterReducer(state.filter, action)
  };
  return nextState;
};
 
const store = createStore(rootReducer);
```

The Redux package helps facilitate this pattern by providing a utility function called combineReducers() which handles this boilerplate for us:
```JS
import { createStore, combineReducers } from 'redux'
 
// todosReducer and filterReducer omitted.
 
const reducers = {
    todos: todosReducer,
    filter: filterReducer
};
const rootReducer = combineReducers(reducers);
const store = createStore(rootReducer);
```

Let‚Äôs break this code down:
* The reducers object contains the slice reducers for the application. The keys of the object correspond to the name of the slice being managed by the reducer value.
* The combineReducers() function accepts this reducers object and returns a rootReducer function.
* The returned rootReducer is passed to createStore() to create a store object.

Just as before, when an action is dispatched to the store, the rootReducer() is executed which then calls each slice reducer, passing along the action and the appropriate slice of state.

The last 6 lines of this example can be rewritten inline:
```JS
const store = createStore(combineReducers({
    todos: todosReducer,
    filter: filterReducer
}));
```

Take a look at store.js where you will find the slice reducers that you created in the last exercise. Now, however, the rootReducer() is missing. Rather than creating this function by hand, you will use combineReducers().

## A File Structure for Redux
At this point, you may have begun thinking that store.js is getting pretty long, and yet the Recipes app only has three slices! Imagine trying to fit the logic for an application with a dozen or more slices into one file. That would not be fun.

Instead, it is more common, and a better practice, to break up a Redux application using the [Redux Ducks pattern](https://github.com/erikras/ducks-modular-redux), like so:
```
src/
|-- index.js
|-- app/
    |-- store.js
|-- features/
    |-- featureA/
        |-- featureASlice.js
    |-- featureB/
        |-- featureBSlice.js
```

As you can see in your coding workspace, this file structure has already been set up for you.

All of the Redux logic lives within the top-level directory called src/. It contains:
* The entry point for the entire application, index.js (we will return to this file in the next exercise).
* The sub-directories app/ and features/.

The src/app/ directory has only one file (for now), store.js. As before, the ultimate purpose of this file is to create the rootReducer and the Redux store. Now, however, you‚Äôll notice that the file is empty! So where did the reducers and action creators go?!

The src/features/ directory, and its own src/features/featureX/ sub-directories, contain all of the code relating to each individual slice of the store‚Äòs state. For example, for the state.favoriteRecipes slice, its slice reducer and action creators can be found in the file called src/features/favoriteRecipes/favoriteRecipesSlice.js.

Lucky for you, we took care of much of the tedious work involved in [refactoring](https://en.wikipedia.org/wiki/Code_refactoring) this code. In addition to creating new folders, new files, and copying over the relevant code, this refactor involved exporting each of the slice reducers and action creators, so that they could be imported back into store.js.

## Passing Store Data Through the Top-Level React Component
The file structure that you helped implement in the last exercise works nicely when we add in React components. Take a look at the src folder in your workspace and you will find the following file structure (new files have a (+) next to their name):
```
src/
|-- index.js
|-- app/
    |-- App.js (+)
    |-- store.js
|-- components/
    |-- FavoriteButton.js (+)
    |-- Recipe.js (+)
|-- features/
    |-- allRecipes/
        |-- AllRecipes.js (+)
        |-- allRecipesSlice.js
    |-- favoriteRecipes/
        |-- FavoriteRecipes.js (+)
        |-- favoriteRecipesSlice.js
    |-- searchTerm/
        |-- SearchTerm.js (+)
        |-- searchTermSlice.js
```

If you look at the actual file structure in your code editor, you may notice a few unfamiliar files / directories not mentioned in the structure above. The test/ directory and index.compiled.js file are used to test your code on Codecademy. You can ignore them. 

The new components are:
* \<App />: The top-level component for the entire application.
* \<AllRecipes />: The component for rendering the recipes loaded from the ‚Äúdatabase‚Äù.
* \<FavoriteRecipes />: The component for rendering the recipes favorited by the user.
* \<SearchTerm />: The component for rendering the search bar that filters the visible recipes.
* \<Recipe /> and \<FavoriteButton />: Generic components used by \<AllRecipes /> and \<FavoriteRecipes />

Aside from the generic components, each feature-related React component file is located in the same directory as the slice file that manages the data rendered by that component. For example, FavoriteRecipes.js and favoriteRecipesSlice.js are both in the src/features/favoriteRecipes/ directory.

Open the src/app/App.js file where the top-level component, \<App />, is stored. As in most React applications, this top-level component will render each feature-component and pass any data needed by those components as prop values. In Redux applications, the data passed to each feature-component includes:
1. The slice of the store‚Äòs state to be rendered. For example, the state.searchTerm slice is passed to the \<SearchTerm /> component.
2. The store.dispatch method to trigger state changes through user interactions within the component. For example, the \<SearchTerm /> component will need to dispatch setSearchTerm() actions.
This distribution of the store.dispatch method and the slices of state to all of the feature-components, via the \<App /> component, begins in the index.js file. Open up the src/index.js file where you will see some standard React code for rendering the top-level \<App /> component. You‚Äôll notice that the store is missing and the \<App /> component isn‚Äôt receiving any props!

## Using Store Data Within Feature Components
At the end of the last exercise, you were able to pass the current state of the store and its store.dispatch method to the top-level component, \<App />. This allowed the \<App /> component to distribute the dispatch method and the slices of the store‚Äòs state to each feature-component.

So it looks like you‚Äôre done, right? Not quite. Try adding a favorite recipe and you‚Äôll see that it just disappears! Take a closer look at App.js and you‚Äôll notice that the \<FavoriteRecipes /> component is missing. Then, open up FavoriteRecipes.js and you‚Äôll see that it is also incomplete. Let‚Äôs fix that.

Plugging in a feature-component to a Redux application involves the following steps:
* Import the React feature-components into the top-level App.js file.
* Render each feature-component and pass along the slice of state and the dispatch method as props.
* Within each feature-component:
  * Extract the slice of state and dispatch from props.
  * Render the component using data from the slice of state.
  * Import any action creators from the associated slice file.
  * Dispatch actions in response to user inputs within the component.

This process is not different from how you implemented a React + Redux application in the past. Now, however, you must consider that the slices of the store‚Äòs state and the dispatch method must be passed through props.

## Review
Congratulations! You‚Äôve learned how to build and organize a React+Redux application with multiple slices of state.

By completing this lesson you now know:.
* The action.payload property is used to hold additional data that the reducer might need to carry out a given action. The name payload is simply a convention and its value can be anything!
* The spread syntax (...) and array methods such as .map(), .slice(), and .filter() can be used to immutably update the state of a complex app.
* Reducer composition is a design pattern for managing a Redux store with multiple slices.
* The root reducer delegates actions to slice reducers that are responsible for updating only their assigned slice of the store‚Äôs state. The root reducer then reassembles the slices into a new state object.
* combineReducers() is a method provided by the redux library that accepts a collection of reducer functions and returns a rootReducer that implements the reducer composition pattern.
* In a Redux application, slice reducers are often written in separate files. This pattern is known as [Redux Ducks](https://github.com/erikras/ducks-modular-redux).

In the Recipes application you completed in the final exercise, the store is passed from the entry point (index.js) through the main \<App /> component as a prop. The \<App /> component can then pass the slices of the store‚Äôs state to its sub-components.

This approach is called ‚Äúprop drilling‚Äù or ‚Äúprop threading‚Äù because the props are ‚Äúthreaded‚Äù through the top-level component in order to get them to the presentational components. This isn‚Äôt ideal considering that the top-level component doesn‚Äôt make use of those props. In the next lesson, you‚Äôll learn how you can use the react-redux library to avoid ‚Äúprop threading‚Äù and more tricks for building robust React+Redux applications!

# Implementing the Redux Store from Scratch

## Who is this article for?
Though the redux package provides the createStore() method for us, examining how this powerful object can be created using vanilla JavaScript will help illuminate how Redux works under the hood. This article is for learners who know how to use the store object but want to solidify their understanding of [its three main methods](https://redux.js.org/api/store).

This article assumes that you have some familiarity with the following Redux-related terms and concepts‚Ä¶
* The one-way data-flow model: state ‚Üí view ‚Üí actions ‚Üí state
* Reducer functions
* Action objects
* The createStore() function provided by the redux package
* The store object and its methods: getState(), dispatch(), and subscribe()

## Part 1: What is the Redux store and how is it used?
The state-management library [Redux](https://redux.js.org/) is centered around a single, powerful object called the store. This one object is responsible for holding the entire application‚Äôs state, receiving action objects and then executing state changes based on the type of the action received, and informing (executing) listener functions when such changes occur.

To help create this store object, the Redux library provides the createStore() function. This function accepts a reducer function as an argument and returns a store object with three essential methods:
* store.getState(): for retrieving the current state value held by the store
* store.dispatch(action): for triggering changes to the state, given an action object
* store.subscribe(listener): for registering listener functions to be called when state changes occur

All of this can be seen in the example below which implements a simple counting application:
```JS
import { createStore } from 'redux';
 
const countReducer = (state = 0, action) => {
  switch (action.type) {  
    case 'increment':  
      return state + 1;
    case 'decrement':  
      return state - 1;
    default:  
      return state;  
  }
}
const store = createStore(reducer);
 
const render = () => {
  document.getElementById('count').text = store.getState(); // Display the current state.
}
render(); // Render once with the initial state of 0.
 
store.subscribe(render); // Re-render on state changes.
 
document.getElementById('plusButton').addEventListener('click', () => {  
  store.dispatch({ type: 'increment' });  // Request a state change.
});
```

With this working knowledge of how to use the createStore() function and the store methods, we can begin to write the outline of this function:
```JS
const createStore = (reducer) => {
  const getState = () => {};
  const dispatch = () => {};
  const subscribe = () => {};
  return { getState, dispatch, subscribe };
}
```

Above, we define createStore() simply as a function with a reducer argument that returns an object containing three methods: getState(), dispatch(), and subscribe().

## Part 2: Holding the current state of the application
Let‚Äôs now turn our attention to the primary responsibility of the store: to hold the current state of the application and to provide access to this value via the store.getState() method. Implementing this behavior is as simple as storing an encapsulated variable (we can call it state) within the function and returning it with store.getState():
```JS
const createStore = (reducer) => {
  let state;
  const getState = () => state;
  const dispatch = () => {};
  const subscribe = () => {};
  return { getState, dispatch, subscribe };
}
```

Hiding the state behind the API of the store avoids common dangers associated with having global variables:
* Polluting the global namespace increases the chances of naming collisions.
* Granting variable access to parts of an application while limiting it to others is impossible.
* Debugging is difficult when a variable is referenced in many parts of the application.

Redux solves these problems by requiring the programmer to use only the store methods to access the state.

## Part 3: Managing Listener Functions
The state of the store will likely change many times and the features of the application must be notified when those changes occur. The store.subscribe() method allows you to subscribe callback functions, called listeners, to be executed when the state data changes. As in the first example, functions that render the view-layer are often subscribed to the store and use store.getState() to get the most up-to-date state data.

Any number of listeners may be subscribed to the store at once so an array is maintained by the store and the subscribe() method adds provided listeners to that array.
```JS
const createStore = (reducer) => {
  let state;
  let listeners = [];
 
  const getState = () => state;
 
  const dispatch = () => {};
 
  const subscribe = (listener) => {
    listeners.push(listener);
    return () => {  
      listeners = listeners.filter(l => l !== listener)  
    }
  };
 
  return { getState, dispatch, subscribe };
}
```

Also notice that the subscribe() method returns a function. If you no longer want the given listener to be executed in response to state changes, this function can be saved and called to unsubscribe the given listener. For example:
```JS
const unsubscribe = store.subscribe(render); // Subscribes `render` to the store.

// somewhere else in the program...
unsubscribe(); // Unsubscribes `render` from the store.
```

## Part 4: Handling Incoming Actions
Redux ensures that the state is maintained reliably by requiring the programmer to dispatch actions to the store if they wish to update the state. The store.dispatch() function accepts an action object as an argument and calculates the next state value by calling the reducer() with the current state and the action:
```JS
const createStore = (reducer) => {
  let state;
  let listeners = [];
 
  const getState = () => state;
 
  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach(listener => listener());
  };
 
  const subscribe = (listener) => {
    listeners.push(listener);
    return () => {  
      listeners = listeners.filter(l => l !== listener)  
    }
  };
 
  dispatch({});
  return { getState, dispatch, subscribe };
}
```

Each listener that has been subscribed to the store (stored in the listeners array) is then executed. Notice that the state is not passed directly to these listeners. It is up to each listener to use store.getState() to get the most up-to-date data.

Finally, notice that before the store object is returned, the function call dispatch({}) is made. This initializes the state value with the default initial state value of the reducer.

Apart from a few details and edge cases, this is the full implementation of the createStore() method provided by the redux package. As you can see, the technology behind the Redux store is not particularly complicated, though the pattern it enforces is incredibly powerful.
